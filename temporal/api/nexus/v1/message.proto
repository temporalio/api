syntax = "proto3";

package temporal.api.nexus.v1;

option go_package = "go.temporal.io/api/nexus/v1;nexus";
option java_package = "io.temporal.api.nexus.v1";
option java_multiple_files = true;
option java_outer_classname = "MessageProto";
option ruby_package = "Temporalio::Api::Nexus::V1";
option csharp_namespace = "Temporalio.Api.Nexus.V1";

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "temporal/api/common/v1/message.proto";
import "temporal/api/enums/v1/common.proto";
import "temporal/api/enums/v1/nexus.proto";
import "temporal/api/failure/v1/message.proto";

// A general purpose failure message.
// See: https://github.com/nexus-rpc/api/blob/main/SPEC.md#failure
message Failure {
    string message = 1;
    map<string, string> metadata = 2;
    // UTF-8 encoded JSON serializable details.
    bytes details = 3;
}

message HandlerError {
    // See https://github.com/nexus-rpc/api/blob/main/SPEC.md#predefined-handler-errors.
    string error_type = 1;
    Failure failure = 2;
    // Retry behavior, defaults to the retry behavior of the error type as defined in the spec.
    temporal.api.enums.v1.NexusHandlerErrorRetryBehavior retry_behavior = 3;
}

message UnsuccessfulOperationError {
    // See https://github.com/nexus-rpc/api/blob/main/SPEC.md#operationinfo.
    string operation_state = 1;
    Failure failure = 2;
}

message Link {
    // See https://github.com/nexus-rpc/api/blob/main/SPEC.md#links.
    string url = 1;
    string type = 2;
}

// When StartNexusOperation uses the OPERATION_ID_CONFLICT_POLICY_USE_EXISTING and there is already an existing running
// operation, OnConflictOptions defines actions to be taken on the existing running operation, updating its state.
message OnConflictOptions {
    // Attaches the request ID to the running operation.
    bool attach_request_id = 1;
    // Attaches the completion callbacks to the running operation.
    bool attach_completion_callbacks = 2;
    // Attaches the links to the running operation.
    bool attach_links = 3;
}

// A request to start an operation.
message StartOperationRequest {
    // Name of service to start the operation in.
    string service = 1;
    // Type of operation to start.
    string operation = 2;
    // A request ID that can be used as an idempotentency key.
    string request_id = 3;
    // Callback URL to call upon completion if the started operation is async.
    string callback = 4;
    // Full request body from the incoming HTTP request.
    temporal.api.common.v1.Payload payload = 5;
    // Header that is expected to be attached to the callback request when the operation completes.
    map<string, string> callback_header = 6;
    // Links contain caller information and can be attached to the operations started by the handler.
    repeated Link links = 7;
}

// A request to cancel an operation.
message CancelOperationRequest {
    // Service name.
    string service = 1;
    // Type of operation to cancel.
    string operation = 2;
    // Operation ID as originally generated by a Handler.
    //
    // Deprecated. Renamed to operation_token.
    string operation_id = 3 [deprecated = true];

    // Operation token as originally generated by a Handler.
    string operation_token = 4;
}

// A Nexus request.
message Request {
    // Headers extracted from the original request in the Temporal frontend.
    // When using Nexus over HTTP, this includes the request's HTTP headers ignoring multiple values.
    map<string, string> header = 1;

    // The timestamp when the request was scheduled in the frontend.
    // (-- api-linter: core::0142::time-field-names=disabled
    //     aip.dev/not-precedent: Not following linter rules. --)
    google.protobuf.Timestamp scheduled_time = 2;

    oneof variant {
        StartOperationRequest start_operation = 3;
        CancelOperationRequest cancel_operation = 4;
    }

    // The endpoint this request was addressed to before forwarding to the worker.
    // Supported from server version 1.30.0.
    string endpoint = 10;
}

// Response variant for StartOperationRequest.
message StartOperationResponse {
    // An operation completed successfully.
    message Sync {
        temporal.api.common.v1.Payload payload = 1;
        repeated Link links = 2;
    }

    // The operation will complete asynchronously.
    // The returned ID can be used to reference this operation.
    message Async {
        // Deprecated. Renamed to operation_token.
        string operation_id = 1 [deprecated = true];
        repeated Link links = 2;
        string operation_token = 3;
    }

    oneof variant {
        Sync sync_success = 1;
        Async async_success = 2;
        // The operation completed unsuccessfully (failed or canceled).
        UnsuccessfulOperationError operation_error = 3;
    }
}

// Response variant for CancelOperationRequest.
message CancelOperationResponse {
}

// A response indicating that the handler has successfully processed a request.
message Response {
    // Variant must correlate to the corresponding Request's variant.
    oneof variant {
        StartOperationResponse start_operation = 1;
        CancelOperationResponse cancel_operation = 2;
    }
}

// A cluster-global binding from an endpoint ID to a target for dispatching incoming Nexus requests.
message Endpoint {
    // Data version for this endpoint, incremented for every update issued via the UpdateNexusEndpoint API.
    int64 version = 1;
    // Unique server-generated endpoint ID.
    string id = 2;
    // Spec for the endpoint.
    EndpointSpec spec = 3;

    // The date and time when the endpoint was created.
    // (-- api-linter: core::0142::time-field-names=disabled
    //     aip.dev/not-precedent: Not following linter rules. --)
    google.protobuf.Timestamp created_time = 4;

    // The date and time when the endpoint was last modified.
    // Will not be set if the endpoint has never been modified.
    // (-- api-linter: core::0142::time-field-names=disabled
    //     aip.dev/not-precedent: Not following linter rules. --)
    google.protobuf.Timestamp last_modified_time = 5;

    // Server exposed URL prefix for invocation of operations on this endpoint.
    // This doesn't include the protocol, hostname or port as the server does not know how it should be accessed
    // publicly. The URL is stable in the face of endpoint renames.
    string url_prefix = 6;
}

// Contains mutable fields for an Endpoint.
message EndpointSpec {
    // Endpoint name, unique for this cluster. Must match `[a-zA-Z_][a-zA-Z0-9_]*`.
    // Renaming an endpoint breaks all workflow callers that reference this endpoint, causing operations to fail.
    string name = 1;

    // Markdown description serialized as a single JSON string.
    // If the Payload is encrypted, the UI and CLI may decrypt with the configured codec server endpoint.
    // By default, the server enforces a limit of 20,000 bytes for this entire payload.
    temporal.api.common.v1.Payload description = 2;

    // Target to route requests to.
    EndpointTarget target = 3;
}

// Target to route requests to.
message EndpointTarget {
    // Target a worker polling on a Nexus task queue in a specific namespace.
    message Worker {
        // Namespace to route requests to.
        string namespace = 1;
        // Nexus task queue to route requests to.
        string task_queue = 2;
    }
  
    // Target an external server by URL.
    // At a later point, this will support providing credentials, in the meantime, an http.RoundTripper can be injected
    // into the server to modify the request.
    message External {
        // URL to call.
        string url = 1;
    }

    oneof variant {
        Worker worker = 1;
        External external = 2;
    }
}

// Information about a Nexus operation.
message NexusOperationInfo {
    // Unique identifier of this operation within its caller namespace along with run ID (below).
    string operation_id = 1;
    string run_id = 2;

    // Endpoint name associated with this operation.
    string endpoint = 3;
    // Name of the service to which this operation belongs.
    string service = 4;
    // Name of the operation as registered with the Temporal worker.
    string operation = 5;
    // A general status for this operation, indicates whether it is currently running or in one of the terminal statuses.
    temporal.api.enums.v1.NexusOperationStatus status = 6;
    // More detailed breakdown of NEXUS_OPERATION_EXECUTION_STATUS_RUNNING.
    temporal.api.enums.v1.PendingNexusOperationState run_state = 7;

    // Time the operation transitioned to started, if the operation is asynchronous.
    google.protobuf.Timestamp started_time = 8;
    // The attempt this operation is currently on.
    // Incremented each time a new attempt is made to send a StartOperation or RequestCancelOperation request to the
    // operation handler.
    int32 attempt = 9;
    int32 maximum_attempts = 10;
    // Time the activity was originally scheduled via a StartNexusOperation request.
    google.protobuf.Timestamp scheduled_time = 11;
    // Scheduled time + schedule to close timeout.
    google.protobuf.Timestamp expiration_time = 12;
    // Failure details from the last failed attempt.
    temporal.api.failure.v1.Failure last_failure = 13;
    // Time from the last attempt failure to the next retry. Calculated from the specified retry policy.
    // If operation is currently backing off between attempts, this represents the current retry interval.
    // If there is no next retry allowed, this field will be null.
    google.protobuf.Duration current_retry_interval = 14;
    // The time when the last request attempt completed. If the StartOperation request has not been completed yet, it will be null.
    google.protobuf.Timestamp last_attempt_complete_time = 15;
    // The time when the next request attempt will be scheduled.
    // If operation is currently started, this field will be null.
    google.protobuf.Timestamp next_attempt_schedule_time = 16;

    // Incremented each time the operation's state is mutated in persistence.
    int64 state_transition_count = 17;

    temporal.api.common.v1.SearchAttributes search_attributes = 18;
    temporal.api.common.v1.Header header = 19;

    // Callbacks to be called by the server when this operation reaches a terminal status.
    // Callback addresses must be whitelisted in the server's dynamic configuration.
    repeated temporal.api.common.v1.Callback completion_callbacks = 20;
    // Links to be associated with the operation.
    repeated temporal.api.common.v1.Link links = 21;

    // Set if operation cancellation was requested.
    string canceled_reason = 22;
}

// Limited Nexus operation information returned in the list response.
// When adding fields here, ensure that it is also present in NexusOperationInfo (note that it
// may already be present in NexusOperationInfo but not at the top-level).
message NexusOperationListInfo {
    // For standalone operations - a unique identifier of this operation within its namespace along with run ID (below).
    string operation_id = 1;
    // The run ID of the workflow or standalone operation.
    string run_id = 2;
    // Workflow that contains this operation - only present for workflow operations.
    string workflow_id = 3;

    // Endpoint name associated with this operation.
    string endpoint = 4;
    // Name of the service to which this operation belongs.
    string service = 5;
    // Name of the operation as registered with the Temporal worker.
    string operation = 6;
    // Time the operation was originally scheduled via a StartNexusOperation request.
    google.protobuf.Timestamp scheduled_time = 7;
    // If the operation is in a terminal status, this field represents the time the operation transitioned to that status.
    google.protobuf.Timestamp close_time = 8;
    // Only scheduled and terminal statuses appear here. More detailed information in PendingNexusOperationInfo but not
    // available in the list response.
    temporal.api.enums.v1.NexusOperationStatus status = 9;

    // Search attributes from the start request.
    temporal.api.common.v1.SearchAttributes search_attributes = 10;

    // Updated on terminal status.
    int64 state_transition_count = 11;
    // Updated once on scheduled and once on terminal status.
    int64 state_size_bytes = 12;
    // The difference between close time and scheduled time.
    // This field is only populated if the operation is closed.
    google.protobuf.Duration execution_duration = 13;
}