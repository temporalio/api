// The MIT License
//
// Copyright (c) 2020 Temporal Technologies Inc.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

syntax = "proto3";

package temporal.api.taskqueue.v1;

option go_package = "go.temporal.io/api/taskqueue/v1;taskqueue";
option java_package = "io.temporal.api.taskqueue.v1";
option java_multiple_files = true;
option java_outer_classname = "MessageProto";
option ruby_package = "Temporalio::Api::TaskQueue::V1";
option csharp_namespace = "Temporalio.Api.TaskQueue.V1";

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";

import "temporal/api/enums/v1/task_queue.proto";
import "temporal/api/common/v1/message.proto";

// See https://docs.temporal.io/docs/concepts/task-queues/
message TaskQueue {
    string name = 1;
    // Default: TASK_QUEUE_KIND_NORMAL.
    temporal.api.enums.v1.TaskQueueKind kind = 2;
    // Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
    // the normal task queue that the sticky worker is running on.
    string normal_name = 3;
}

// Only applies to activity task queues
message TaskQueueMetadata {
    // Allows throttling dispatch of tasks from this queue
    google.protobuf.DoubleValue max_tasks_per_second = 1;
}

message TaskQueueStatus {
    int64 backlog_count_hint = 1;
    int64 read_level = 2;
    int64 ack_level = 3;
    double rate_per_second = 4;
    TaskIdBlock task_id_block = 5;
}

message TaskIdBlock {
    int64 start_id = 1;
    int64 end_id = 2;
}

message TaskQueuePartitionMetadata {
    string key = 1;
    string owner_host_name = 2;
}

message PollerInfo {
    google.protobuf.Timestamp last_access_time = 1;
    string identity = 2;
    double rate_per_second = 3;
    // If a worker has opted into the worker versioning feature while polling, its capabilities will
    // appear here.
    temporal.api.common.v1.WorkerVersionCapabilities worker_version_capabilities = 4;
}

message StickyExecutionAttributes {
    TaskQueue worker_task_queue = 1;
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration schedule_to_start_timeout = 2;
}

// Used by the worker versioning APIs, represents an unordered set of one or more versions which are
// considered to be compatible with each other. Currently the versions are always worker build IDs.
message CompatibleVersionSet {
    // All the compatible versions, unordered, except for the last element, which is considered the set "default".
    repeated string build_ids = 1;
}

// Reachability of tasks for a worker on a single task queue.
message TaskQueueReachability {
    string task_queue = 1;
    // Task reachability for a worker in a single task queue.
    // See the TaskReachability docstring for information about each enum variant.
    // If reachability is empty, this worker is considered unreachable in this task queue.
    repeated temporal.api.enums.v1.TaskReachability reachability = 2;
}

// Reachability of tasks for a worker by build id, in one or more task queues.
message BuildIdReachability {
    // A build id or empty if unversioned.
    string build_id = 1;
    // Reachability per task queue.
    repeated TaskQueueReachability task_queue_reachability = 2;
}

// These rules assign a Build ID to Unassigned Workflow Executions and
// Activities.
//
// Specifically, assignment rules are applied to the following Executions or
// Activities when they are scheduled in a Task Queue:
//    - Generally, any new Workflow Execution, except:
//      - Child Workflows started without overriding their Task Queue or
//        assignment status.
//      - Continue-As-New Executions started without overriding assignment
//        status.
//      - Workflow Executions started Eagerly.
//    - An Activity that is scheduled on a Task Queue different from the one
//      their Workflow runs on, without overriding assignment status.
//
// In absence of (applicable) redirect rules (`CompatibleBuildIdRedirectRule`s)
// the task will be dispatched to Workers of the Build ID determined by the
// assignment rules. Otherwise, the final Build ID will be determined by the
// redirect rules.
//
// When using Worker Versioning, in the steady state, for a given Task Queue,
// there should typically be exactly one assignment rule to send all Unassigned
// tasks to the latest Build ID. Existence of at least one such "unconditional"
// rule at all times is enforce by the system, unless the `force` flag is used
// by the user when replacing/deleting these rules (for exceptional cases).
//
// During a deployment, one or more additional rules can be added to assign a
// subset of the tasks to a new Build ID.
//
// The subset is defined by:
//    - Including or excluding particular values of the `VersioningHint` Search
//      Attribute. This is useful for Canary deployments, for example, when
//      only the executions with `versioning_hint="canary"` should be sent to
//      the new Build ID.
//    - And/or setting a `ramp_percentage` value. This is useful for gradual
//      shift of the traffic To the new Build ID in Blue/Green deployments and
//      alike.
//
// Additionally, the rule can be contingent upon the availability of target
// Workers. This is useful for rolling deployments, when the gradual shift of
// traffic to the new Build ID is driven by the gradual upgrade of the Workers,
// rather than a `ramp_percentage` value.
//
// When there are multiple assignment rules for a Task Queue, the rules are
// evaluated in order, starting from index 0. The first applicable rule will be
// applied and the rest will be ignored.
//
// In the event that no assignment rule is applicable on a task (or the Task
// Queue is simply not versioned), the tasks will be sent to unversioned
// workers, if available. Otherwise, they remain Unassigned, and will be
// retried for assignment, or dispatch to unversioned workers, at a later time
// depending on the availability of workers.
message BuildIdAssignmentRule {
    string target_build_id = 1;

    // Filter executions based on the "VersioningHint" Search Attribute set by
    // the Starter or parent Workflow.
    string hint_filter = 2;

    // Among the tasks that match the hint filter, only this percentage of them
    // to be sent to the target Build ID.
    // The default ramp value is 100. The valid range is [0-100].
    float ramp_percentage = 3;

    // This option is intended for rolling deployments. When enabled, we try
    // immediate dispatch to the target Build ID. If no poller is available, we
    // skip this rule for the task at hand.
    // This option can be used only on "terminal" Build IDs (the ones not used
    // as source in any redirect rules).
    bool contingent_on_worker_availability = 4;
}

// These rules apply to tasks assigned to a particular Build ID
// (`source_build_id`) to redirect them to another *compatible* Build ID
// (`target_build_id`).
//
// It is user's responsibility to ensure that the target Build ID is compatible
// with the source Build ID (e.g. by using the Patching API).
//
// Most deployments are not expected to need these rules, however following
// situations can greatly benefit from redirects:
//  - Need to move long-running Workflow Executions from an old Build ID to a
//    newer one.
//  - Need to hotfix some broken or stuck Workflow Executions.
//
// Similar to the assignment rules, redirect rules can be contingent upon the
// availability of target Workers, which is useful for rolling deployments.
//
// In steady state, redirect rules are beneficial when dealing with old
// Executions ran on now-decommissioned Build IDs:
//  - To redirecting the Workflow Queries to the current (compatible) Build ID.
//  - To be able to Reset an old Execution so it can run on the current
//    (compatible) Build ID.
//
// Redirect rules can be chained, but only the last rule in the chain can have
// the `contingent_on_worker_availability` options enabled.
message CompatibleBuildIdRedirectRule {
    string source_build_id = 1;
    string target_build_id = 2;

    // This option is intended for rolling deployments. When enabled, we try
    // immediate dispatch to the target Build ID. If it has no available
    // pollers, we fallback to the source Build ID.
    // This option can be used only on "terminal" Build IDs (the ones not used
    // as source in any redirect rules).
    bool contingent_on_worker_availability = 3;
}
