// The MIT License
//
// Copyright (c) 2020 Temporal Technologies Inc.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

syntax = "proto3";

package temporal.api.taskqueue.v1;

option go_package = "go.temporal.io/api/taskqueue/v1;taskqueue";
option java_package = "io.temporal.api.taskqueue.v1";
option java_multiple_files = true;
option java_outer_classname = "MessageProto";
option ruby_package = "Temporalio::Api::TaskQueue::V1";
option csharp_namespace = "Temporalio.Api.TaskQueue.V1";

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";

import "temporal/api/enums/v1/task_queue.proto";
import "temporal/api/common/v1/message.proto";

// See https://docs.temporal.io/docs/concepts/task-queues/
message TaskQueue {
    string name = 1;
    // Default: TASK_QUEUE_KIND_NORMAL.
    temporal.api.enums.v1.TaskQueueKind kind = 2;
    // Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
    // the normal task queue that the sticky worker is running on.
    string normal_name = 3;
}

// Represents a normal or sticky partition of a task queue.
message TaskQueuePartition {
    // Normal task queue name.
    string task_queue_name = 1;
    temporal.api.enums.v1.TaskQueueType task_queue_type = 2;
    // Absent means normal root partition (normal_partition_id=0)
    oneof partition_id {
        int32 normal_partition_id = 3;
        int32 sticky_name = 4;
    }
}

// Only applies to activity task queues
message TaskQueueMetadata {
    // Allows throttling dispatch of tasks from this queue
    google.protobuf.DoubleValue max_tasks_per_second = 1;
}

message TaskQueueVersionInfo {
    // Empty means unversioned.
    string build_id = 1;
    repeated TaskQueueTypeInfo types_info = 3;
    // Only applicable to versioned workers (workers with `useVersioning=true`).
    temporal.api.enums.v1.BuildIdTaskReachability task_reachability = 4;
}

message TaskQueueTypeInfo {
    temporal.api.enums.v1.TaskQueueType type = 1;
    // Unversioned workers (with `useVersioning=false`) are reported in unversioned result even if they set a Build ID.
    repeated PollerInfo pollers = 2;
    BacklogInfo backlog_info = 3;
}

// For workflow task queues, we only report the normal queue metrics, not sticky queues. This means the stats
// reported here do not count all workflow tasks. However, because the tasks queued in sticky queues only remain
// valid for a few seconds, the inaccuracy becomes less significant as the backlog age grows.
message BacklogInfo {
    // The approximate number of tasks backlogged in this task queue. May count expired tasks but eventually converges
    // to the right value.
    int64 approximate_backlog_count = 1;
    // Approximate age of the backlog based on the create timestamp of the task at the head of the queue.
    google.protobuf.Duration approximate_backlog_age = 2;
    // Approximate tasks per second added to the queue based on recent activity
    float tasks_add_rate = 3;
    // Approximate tasks per second dispatched to workers based on recent activity
    float tasks_dispatch_rate = 4;
}

message InternalTaskQueueStatus {
    int64 backlog_count_hint = 1;
    int64 read_level = 2;
    int64 ack_level = 3;
    double rate_per_second = 4;
    TaskIdBlock task_id_block = 5;
}

// Deprecated. Use `InternalTaskQueueStatus`. This is kept until `DescribeTaskQueue` supports legacy behavior.
message TaskQueueStatus {
    int64 backlog_count_hint = 1;
    int64 read_level = 2;
    int64 ack_level = 3;
    double rate_per_second = 4;
    TaskIdBlock task_id_block = 5;
}

message TaskIdBlock {
    int64 start_id = 1;
    int64 end_id = 2;
}

message TaskQueuePartitionMetadata {
    string key = 1;
    string owner_host_name = 2;
}

message PollerInfo {
    google.protobuf.Timestamp last_access_time = 1;
    string identity = 2;
    double rate_per_second = 3;
    // If a worker has opted into the worker versioning feature while polling, its capabilities will
    // appear here.
    temporal.api.common.v1.WorkerVersionCapabilities worker_version_capabilities = 4;
}

message StickyExecutionAttributes {
    TaskQueue worker_task_queue = 1;
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration schedule_to_start_timeout = 2;
}

// Used by the worker versioning APIs, represents an unordered set of one or more versions which are
// considered to be compatible with each other. Currently the versions are always worker build IDs.
message CompatibleVersionSet {
    // All the compatible versions, unordered, except for the last element, which is considered the set "default".
    repeated string build_ids = 1;
}

// Reachability of tasks for a worker on a single task queue.
message TaskQueueReachability {
    string task_queue = 1;
    // Task reachability for a worker in a single task queue.
    // See the TaskReachability docstring for information about each enum variant.
    // If reachability is empty, this worker is considered unreachable in this task queue.
    repeated temporal.api.enums.v1.TaskReachability reachability = 2;
}

// Reachability of tasks for a worker by build id, in one or more task queues.
message BuildIdReachability {
    // A build id or empty if unversioned.
    string build_id = 1;
    // Reachability per task queue.
    repeated TaskQueueReachability task_queue_reachability = 2;
}

message RampByPercentage {
    // Acceptable range is [0,100).
    float ramp_percentage = 1;
}

message RampByWorkerRatio {
}

// These rules assign a Build ID to Unassigned Workflow Executions and
// Activities.
//
// Specifically, assignment rules are applied to the following Executions or
// Activities when they are scheduled in a Task Queue:
//    - Generally, any new Workflow Execution, except:
//      - When A Child Workflow or a Continue-As-New Execution inherits the
//        Build ID from its parent/previous execution by setting the
//        `inherit_build_id` flag.
//      - Workflow Executions started Eagerly are assigned to the Build ID of
//        the Starter.
//    - An Activity that is scheduled on a Task Queue different from the one
//      their Workflow runs on, unless the `use_workflow_build_id` flag is set.
//
// In absence of (applicable) redirect rules (`CompatibleBuildIdRedirectRule`s)
// the task will be dispatched to Workers of the Build ID determined by the
// assignment rules. Otherwise, the final Build ID will be determined by the
// redirect rules.
//
// When using Worker Versioning, in the steady state, for a given Task Queue,
// there should typically be exactly one assignment rule to send all Unassigned
// tasks to the latest Build ID. Existence of at least one such "unconditional"
// rule at all times is enforce by the system, unless the `force` flag is used
// by the user when replacing/deleting these rules (for exceptional cases).
//
// During a deployment, one or more additional rules can be added to assign a
// subset of the tasks to a new Build ID based on a "ramp percentage".
//
// When there are multiple assignment rules for a Task Queue, the rules are
// evaluated in order, starting from index 0. The first applicable rule will be
// applied and the rest will be ignored.
//
// In the event that no assignment rule is applicable on a task (or the Task
// Queue is simply not versioned), the tasks will be sent to unversioned
// workers, if available. Otherwise, they remain Unassigned, and will be
// retried for assignment, or dispatch to unversioned workers, at a later time
// depending on the availability of workers.
message BuildIdAssignmentRule {
    string target_build_id = 1;

    // If a ramp is provided, this rule will be applied only to a sample of
    // tasks according to the provided percentage.
    // This option can be used only on "terminal" Build IDs (the ones not used
    // as source in any redirect rules).
    oneof ramp {
        // This ramp is useful for gradual Blue/Green deployments (and similar)
        // where you want to send a certain portion of the traffic to the target
        // Build ID.
        RampByPercentage percentage_ramp = 3;
    }
}

// These rules apply to tasks assigned to a particular Build ID
// (`source_build_id`) to redirect them to another *compatible* Build ID
// (`target_build_id`).
//
// It is user's responsibility to ensure that the target Build ID is compatible
// with the source Build ID (e.g. by using the Patching API).
//
// Most deployments are not expected to need these rules, however following
// situations can greatly benefit from redirects:
//  - Need to move long-running Workflow Executions from an old Build ID to a
//    newer one.
//  - Need to hotfix some broken or stuck Workflow Executions.
//
// In steady state, redirect rules are beneficial when dealing with old
// Executions ran on now-decommissioned Build IDs:
//  - To redirecting the Workflow Queries to the current (compatible) Build ID.
//  - To be able to Reset an old Execution so it can run on the current
//    (compatible) Build ID.
//
// Redirect rules can be chained, but only the last rule in the chain can have
// a ramp.
message CompatibleBuildIdRedirectRule {
    string source_build_id = 1;
    string target_build_id = 2;
}

message TimestampedBuildIdAssignmentRule {
    BuildIdAssignmentRule rule = 1;
    google.protobuf.Timestamp create_time = 2;
}

message TimestampedCompatibleBuildIdRedirectRule {
    CompatibleBuildIdRedirectRule rule = 1;
    google.protobuf.Timestamp create_time = 2;
}